{% extends 'base.html.twig' %}

{% block title %}Redovisning{% endblock %}

{% block body %}
    <h2>Redovisning</h2>
    <article>
        <aside>
            <ul>
                <li><p><a href="#kmom01">Kmom01</a></p></li>
                <li><p><a href="#kmom02">Kmom02</a></p></li>
                <li><p><a href="#kmom03">Kmom03</a></p></li>
                <li><p><a href="#kmom04">Kmom04</a></p></li>
                <li><p><a href="#kmom05">Kmom05</a></p></li>
                <li><p><a href="#kmom06">Kmom06</a></p></li>
                <li><p><a href="#kmom10">Kmom10</a></p></li>
            </ul>
        </aside>
        <section id="kmom01">
            <h3 id="kmom01">Kmom01</h3>
            <h4>Berätta kort om dina förkunskaper och tidigare erfarenheter kring objektorientering.</h4>
            <p>Jag har tidigare jobbat med objektorientering genom mindre projekt i JavaScript. Jag är bekant med grunderna som klasser, objekt, arv och inkapsling, men min praktiska erfarenhet av att bygga objektorienterade system i PHP är begränsad. Detta kursmoment gav mig chansen att omsätta teorin i praktiken med Symfony.</p>
            <h4>Berätta kort om PHPs modell för klasser och objekt. Vilka är de grunder man behöver veta/förstå för att kunna komma igång och skapa sina första klasser?</h4>
            <p>PHPs modell för objektorientering bygger på klasser och objekt, där en klass är en mall och ett objekt är en instans av den mallen. För att komma igång behöver man förstå:</p>
            <p><strong>Klassdeklaration</strong>: Använda class för att definiera en klass och egenskaper/metoder.</p>
            <p><strong>Objekt</strong>: Skapa instanser med new.</p>
            <p><strong>Egenskaper och metoder</strong>: Hantera data (public, private, protected) och beteende.</p>
            <p><strong>Arv</strong>: Använda extends för att ärva från en annan klass.</p>
            <p><strong>Namespaces</strong>: Organisera kod med namespace och use för att undvika konflikter.</p>
            <h4>Reflektera kort över den kodbas, koden, strukturen som användes till uppgiften me/report, hur uppfattar du den?</h4>
            <p>Kodbasen i me/report är välstrukturerad tack vare Symfony. Jag gillar hur controllerna (ApiController, MeController) separerar logik från vyer (Twig-mallar) och hur routing med annoteringar gör det enkelt att definiera URL:er. Strukturen med src/, templates/ och public/ är logisk. jag ser potentialen i ramverket men behöver mer tid för att bemästra det.</p>
            <h4>Med tanke på artikeln “PHP The Right Way”, vilka delar in den finner du extra intressanta och värdefulla? Är det några särskilda områden som du känner att du vill veta mer om? Lyft fram några delar av artikeln som du känner mer värdefulla.</h4>
            <p><strong>Testing</strong>: Artikeln betonar vikten av enhetstester och introducerar verktyg som PHPUnit. Jag ser hur testning kan göra koden mer pålitlig. Jag vill gärna lära mig mer om hur man skriver praktiska tester för Symfony-komponenter.</p>
            <p><strong>Security</strong>: Säkerhetsavsnittet tar upp grunderna som att skydda mot SQL-injektioner och XSS-attacker, samt vikten av att använda ramverkens inbyggda skydd. Jag är nyfiken på att fördjupa mig i hur man implementerar säkra API:er och hanterar användarinput på rätt sätt.</p>
            <h4>TIL</h4>
            <p>Min TIL för detta kursmoment är hur Symfony kombinerar objektorientering med dependency injection och routing för att skapa en kraftfull struktur. Att använda AbstractController och JsonResponse för att bygga en JSON API var nytt och lärorikt.</p>
        </section>
         <section id="kmom02">
            <h3 id="kmom02">Kmom02</h3>
            <h4>Förklara kort de objektorienterade konstruktionerna arv, komposition, interface och trait och hur de används i PHP.</h4>
            <p>Arv innebär att en klass ärver egenskaper och metoder från en superklass med <code>extends</code>. I min kod ärver <code>CardGraphic</code> från <code>Card</code>, vilket gör att den kan använda och överskrida metoder som <code>getAsString()</code>. Komposition är när en klass innehåller instanser av andra klasser, som <code>CardHand</code> och <code>DeckOfCards</code> som lagrar flera <code>Card</code>-objekt i en array (1-till-många-relation). Interface definierar ett kontrakt med metoder som klasser måste implementera. Trait delar återanvändbar kod mellan klasser.</p>
            <h4>Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden och dina klasser?</h4>
            <p>Jag byggde ett kortspel i Symfony enligt MVC-mönstret, med fokus på att skapa en robust applikation. Jag implementerade fyra klasser i <code>src/Card/</code>: <code>Card</code> som en basklass med attributen <code>suit</code> och <code>value</code>, <code>CardGraphic</code> som ärver från <code>Card</code> och hanterar SVG-bilder från Wikimedia Commons (t.ex. <code>https://upload.wikimedia.org/wikipedia/commons/d/de/English_pattern_10_of_diamonds.svg</code>), <code>CardHand</code> för att representera en korthand, och <code>DeckOfCards</code> för att hantera kortleken med metoder som <code>shuffle()</code>, <code>draw()</code>, och <code>getSortedCards()</code>. Sessionhantering implementerades med array-baserad lagring (<code>toArray()</code> och <code>fromArray()</code>) för att undvika serialiseringsproblem, vilket säkerställde att kortleken korrekt visar 47 kort efter att ha dragit 5.</p>
            <p>För webbsidorna skapade jag rutter i <code>CardController.php</code>: <code>/card</code> visar ett UML-diagram och länkar, <code>/session</code> visar sessionens innehåll med <code>"empty"</code> för tom session
            , <code>/session/delete</code> rensar sessionen med ett flash-meddelande, och <code>/card/deck</code>, <code>/card/deck/shuffle</code>, <code>/card/deck/draw</code>, samt <code>/card/deck/draw/:number</code> hanterar kortleksoperationer. JSON API-rutter i <code>ApiController.php</code> implementerades för <code>/api/quote</code>, <code>/api/time</code>, <code>/api/deck</code>, <code>/api/deck/shuffle</code>, <code>/api/deck/draw</code>, och <code>/api/deck/draw/:number</code> .</p>
            <p>Stylingen i <code>app.css</code> ger en professionell kortspelskänsla med en mörkgrön filtliknande bakgrund, kort i storleken 110x154px med rundade hörn och hovereffekter, och en kortliknande layout för API-rutter.</p>
            <p>Jag är mycket nöjd med designen och funktionaliteten, särskilt den autentiska känslan från SVG-bilderna och den stabila sessionhanteringen. UML-diagrammet på <code>/card</code> ger en tydlig översikt av klasserna. Jag är något missnöjd med laddningstiderna för SVG-bilderna, som kan vara långsamma på grund av externa förfrågningar till Wikimedia Commons.</p>
            <p><strong>Förbättringspotential</strong>: 
            <ul>
                <li><strong>Prestanda</strong>: Spara SVG-bilderna lokalt i <code>public/images/cards/</code> för snabbare laddning och minskad beroende av externa resurser.</li>
                <li><strong>Funktionalitet</strong>: Implementera den valfria <code>/card/deck/deal/:players/:cards</code>-routen för att stödja kortutdelning till flera spelare.</li>
                <li><strong>Kodstruktur</strong>: Lägga till ett <code>CardInterface</code> för att definiera obligatoriska metoder, eller använda traits för återanvändbar kod.</li>
           </ul>
            <h4>Vilka är dina reflektioner så här långt med att jobba i Symfony med applikationskod enligt MVC?</h4>
            <p>Symfony och MVC gör koden organiserad. Modellerna (<code>Card</code>, <code>DeckOfCards</code>) hanterar logik, vyerna (Twig-mallar) styr presentation, och controllerna binder samman dem. Sessionhantering och routing är kraftfulla. Jag uppskattar hur ramverket underlättar kodstandardisering.</p>
            <h4>TIL</h4>
            <p>Min TIL är vikten av objektorienterade principer som arv och komposition, samt hur Symfony’s sessionhantering och Twig-mallar förenklar utveckling. Jag lärde mig också att hantera externa SVG-bilder.</p>
        </section>
        <section id="kmom03">
            <h3 id="kmom03">Kmom03</h3>
            <h4>Modellering av kortspelet med flödesdiagram och pseudokod</h4>
            <p>Att modellera Game21 med flödesdiagram och pseudokod var en mycket värdefull process. Flödesdiagrammet gav en tydlig visuell översikt över spelets struktur, från insatsfasen till spelarens och bankens drag, vilket gjorde det enklare att identifiera alla möjliga tillstånd och beslutspunkter, såsom när spelaren går över 21 eller banken når ≥17. Pseudokoden hjälpte mig att bryta ner logiken i mindre, hanterbara steg, som att hantera insatser, kortdragning och vinnarbestämning. Detta stödde problemlösningen genom att ge en klar plan innan jag började koda, vilket minskade risken för fel och gjorde det lättare att strukturera klasserna <code>Game21</code>, <code>Player</code>, och <code>DeckOfCards</code>. Jag tror att denna modellering är ett kraftfullt verktyg för att organisera tankearbetet, särskilt för applikationer med komplexa interaktioner, och det hjälpte mig att säkerställa att alla spelregler implementerades korrekt.</p>
            <h4>Implementationen</h4>
            <p><strong>Spelregler och logik i <code>Game21.php</code></strong>: Jag byggde vidare på kortlekskoden från Kmom02 (<code>Card</code>, <code>CardGraphic</code>, <code>CardHand</code>, <code>DeckOfCards</code>) och skapade <code>Game21</code>-klassen för att hantera spelets logik. Klassen styr spelets tillstånd (<code>betting</code>, <code>playing</code>, <code>player_stand</code>, <code>finished</code>) och implementerar regler som att spelaren drar kort för att komma nära 21 utan att gå över, medan banken drar till minst 17. En central del var insatslogiken: banken bidrar med 50 till potten, spelarens insats är begränsad till 1–50, och vid vinst får spelaren 2x insatsen (t.ex. insats 20 ger 40 tillbaka, spelarens pengar blir 120, potten återställs till 50), medan banken får insatsen vid vinst (bankens pengar blir 120, potten återställs till 50). Jag implementerade hantering av ess (värde 1 eller 14) i <code>Player.php</code> för att maximera spelarens poäng utan att gå över 21. En utmaning var att säkerställa korrekt sessionhantering för att behålla spelstate mellan handlingar, vilket löstes genom att serialisera <code>Game21</code>-objektet till sessionen med <code>toArray()</code> och <code>fromArray()</code> metoder. Detta krävde noggrann testning för att säkerställa att tillstånd som pott, pengar och kort sparades korrekt.</p>
            <p><strong>Användargränssnitt i <code>play.html.twig</code>, <code>index.html.twig</code>, <code>doc.html.twig</code>, och <code>api/index.html.twig</code></strong>: Jag förbättrade spelbordet i <code>play.html.twig</code> för att visa pott, spelarens och bankens pengar, kort och poäng tydligt. För API-sidan implementerade jag en gridbaserad layout med hover-effekter för att visa rutter som <code>/api/game</code> och <code>/api/quote</code> på ett tydligt sätt. En utmaning var att göra designen responsiv, vilket löstes med media queries som minskar kortstorlekar (t.ex. till 65px på 480px-skärmar) och justerar layouten för mindre skärmar.</p>
            <p><strong>JSON API i <code>ApiController.php</code></strong>: För att uppfylla <strong>Kortspel JSON</strong> kravet implementerade jag <code>/api/game</code> i <code>ApiController.php</code>, som returnerar spelstate som JSON, inklusive pott, spelarens och bankens kort (med <code>svgUrl</code> och <code>string</code>), poäng, pengar, och status. Jag utökade detta med rutter som <code>/api/quote</code>, <code>/api/time</code>, <code>/api/deck</code>, <code>/api/deck/shuffle</code>, <code>/api/deck/draw</code>, och <code>/api/deck/draw/:number</code>. En utmaning var att säkerställa att kortens SVG-URL:er returnerades korrekt, vilket krävde att <code>CardGraphic</code> genererade rätt bildlänkar från Wikimedia Commons. Jag testade API:et med <code>curl</code> för att verifiera korrekta JSON-svar.</p>
            <p><strong>Kodkvalitet med PHPMD och PHPStan</strong>: Jag integrerade PHPMD och PHPStan i <code>tools/phpmd</code> och <code>tools/phpstan</code>, med konfigurationsfiler (<code>phpmd.xml</code>, <code>phpstan.neon</code>) och Composer-skript (<code>composer phpmd</code>, <code>composer phpstan</code>, <code>composer lint</code>). En stor utmaning var att lösa 23 PHPStan-fel, inklusive saknade typanvisningar för arrayer i <code>Card.php</code>, <code>CardHand.php</code>, <code>DeckOfCards.php</code>, <code>Game21.php</code>, och <code>Player.php</code> (t.ex. <code>@return array<string, mixed></code> för <code>toArray()</code>), samt null-hanteringsproblem i <code>Game21.php</code> där <code>$currentBet</code> kunde vara <code>null</code> i anrop till <code>Player::addMoney()</code>. Jag lade till null-kontroller och typanvisningar, vilket förbättrade kodens robusthet. PHPMD hjälpte mig att identifiera potentiella problem med kodkomplexitet, vilket ledde till renare klasser.</p>
            <p><strong>Dokumentation och visualisering i <code>doc.html.twig</code></strong>: Jag skapade en dokumentationssida med ett flödesdiagram och pseudokod som beskriver spelets flöde, vilket var avgörande för att planera implementationen. Stylingen matchar kasinotemat med en gridbaserad layout och hover-effekter.</p>
            <p><strong>Nöjdhet</strong>: Jag är mycket nöjd med implementationen, särskilt insatslogiken, den visuella designen med kasinotema, och kodkvaliteten efter att ha löst PHPStan-felen. Den stabila sessionhanteringen och API:et är också starka punkter. </p>
            <p><strong>Förbättringspotential</strong>:
            <ul>
                <li><strong>Funktionalitet</strong>: Implementera en valfri <code>/card/deck/deal/:players/:cards</code>-rutt för att stödja kortutdelning till flera spelare, eller lägga till en smartare bank som baserar drag på sannolikheter.</li>
                <li><strong>Kodstruktur</strong>: Bryta ut <code>Game21.php</code>:s vinnarlogik (<code>determineWinner</code>) i mindre metoder för bättre läsbarhet och underhållbarhet.</li>
                <li><strong>Testning</strong>: Lägga till enhetstester för klasser som <code>Game21</code> och <code>Player</code> för att säkerställa robust logik.</li>
                <li><strong>Responsivitet</strong>: Ytterligare optimering av kortstorlekar för extremt små skärmar.</li>
            </ul></p>
            <h4>Vilka är dina reflektioner så här långt med att jobba i Symfony med applikationskod enligt MVC?</h4>
            <p>Att arbeta i Symfony med MVC-strukturen känns alltmer naturligt, men det har varit en inlärningskurva. Modellerna (<code>Card</code>, <code>DeckOfCards</code>, <code>Game21</code>) hanterar spelets logik på ett organiserat sätt, medan vyerna (Twig-mallar som <code>play.html.twig</code> och <code>api/index.html.twig</code>) styr presentationen, och controllerna (<code>GameController.php</code>, <code>ApiController.php</code>) binder samman dem. Jag uppskattar hur Symfony underlättar sessionhantering för att spara spelstate och routing för att skapa API:er som <code>/api/game</code>. En utmaning var att förstå hur man bäst använder Twig och sessioner för att skapa en smidig användarupplevelse, men detta blev enklare med tiden. Symfony’s standardiserade struktur och verktyg som PHPMD och PHPStan gör det lättare att skriva ren och säker kod. Jag ser fram emot att utforska fler Symfony-funktioner, som beroendeinjektion och enhetstester, i kommande kursmoment.</p>
            <h4>TIL</h4>
            <p>Min TIL för Kmom03 är hur objektorienterade principer som arv och komposition, kombinerat med MVC-strukturen i Symfony, skapar en robust och organiserad kodbas. Genom att använda arv i <code>CardGraphic</code> (som ärver från <code>Card</code>) och komposition i <code>Game21</code> (som använder <code>DeckOfCards</code> och <code>Player</code>) lärde jag mig att strukturera komplexa applikationer effektivt. Att integrera PHPMD och PHPStan, och lösa 23 PHPStan-fel genom att lägga till typanvisningar (t.ex. <code>@return array<string, mixed></code>) och hantera null-värden, gav mig insikt i hur statisk kodanalys förbättrar kodkvaliteten och minskar buggar. Dessutom förstärkte användningen av flödesdiagram och pseudokod vikten av problemlösningstekniker som top-down och bottom-up för att planera och implementera spelets logik. Slutligen lärde jag mig hur Symfonys sessionhantering och routing underlättar byggandet av dynamiska webbapplikationer, särskilt genom att skapa JSON API-rutter som <code>/api/game</code> för att exponera spelstate. Dessa lärdomar kommer att vara ovärderliga för framtida projekt.</p>
        </section>
{% endblock %}

